学习计划：
seata
hadoop/flink/spark/hive
GraphQL
DDD --- 学习中
minio/seaweedfs
spring alibaba cloud---xxx

serverless/istio ---ok
React(icejs/antd) ---ok
MyBatis-Plus(dynamic-datasource) ---ok
Kubernetes---ok
spring cloud kubernetes---ok
kylin---ok
rocketmq---ok
中台架构与实现 ---ok

书籍学习：
支付平台架构
精通以太坊
超大系统分布式流量解决方案
云原生应用管理
istio服务网格技术解析与实践
领域驱动设计: 学习中
微服务设计模式

其他学习：
已经购买的一些学习视频（极客）

微信公众号学习：
Java架构师之路
架构师之路
高可用架构
Java后端技术
程序员DD
阿里技术
云时代架构
51CTO技术栈
淘系技术
大数据云技术

-------------------------------------------------


培训计划：
1. java单元测试与集成测试培训 --- ok
2. 领域驱动设计(DDD)系列一 --- ok
3. 领域驱动设计(DDD)系列二 ---ok
4. kubernetes istio培训
5. eclipse与vscode插件开发
6. SaaS多租户平台架构设计讲解
7. Jenkins构建与代码质量检测
8. kubernetes系列课程之二


docker build -t dave/ubuntu:20.04 . -f Dockerfile.ubuntu
docker build -t dave/fabric:2.4.3 . -f Dockerfile
docker save -o ./images/fabric2.4.3.tar 861a2e80d2f4




Step 1:
cd /data/vagrant/docker
vagrant destroy node1 -f
rm -fr /data/var-lib-docker/
vagrant up node1

#Entering the container:
#vagrant docker-exec -it node1 -- /bin/bash
#docker exec -it `docker ps|grep node1|awk '{print $1}'` /vagrant/changepwd.sh
docker exec -it `docker ps|grep node1|awk '{print $1}'` /vagrant/images/importImages.sh
vagrant reload node1
#Then login with terminal, not docker exec
<!-- docker restart `docker ps|grep node1|awk '{print $1}'` -->



<!-- Step 1: From scratch
apt install -y docker-compose
vim /etc/profile.d/env.sh
export PATH=/data/fabric/go/bin:$PATH

. /etc/profile

#The following installation just only from developing chaincode by javascript:
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
. ~/.bashrc
#显示有远端的版本
nvm ls-remote
#安装对应的版本
nvm install v14.19.3
npm config set registry https://registry.npmmirror.com --global
npm config set disturl https://npmmirror.com/dist --global
#npm install yarn -g
#npm install http-server -g

#yarn config set registry https://registry.npmmirror.com --global
#yarn config set disturl https://npmmirror.com/dist --global
#yarn global add serve

#The following installation just only from developing chaincode by java:

#https://hyperledger-fabric.readthedocs.io/en/latest/install.html
apt install -y docker-compose
cd /data/fabric
curl -sSLO https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/install-fabric.sh && chmod +x install-fabric.sh
proxy_on
./install-fabric.sh --fabric-version 2.4.3 docker
./install-fabric.sh --fabric-version 2.4.3 binary
./install-fabric.sh --fabric-version 2.4.3 samples

proxy_off
mv bin config fabric-samples/
cd /data/fabric/fabric-samples/test-network -->

<!-- #For second time:
apt install docker-compose
mkdir -p /data/
ln -s /vagrant/fabric /data/fabric
cd /data/fabric
./install-fabric.sh --fabric-version 2.4.3 docker -->

Step 2:
#https://hyperledger-fabric.readthedocs.io/en/latest/test_network.html

# Starting a chaincode on the channel
#Openning a new terminal to input the following command:
cd /data/fabric/fabric-samples/test-network
<!-- ./network.sh up 
#Creating a channel
./network.sh createChannel -->
./network.sh up createChannel
#Monitor:
./monitordocker.sh fabric_test

# Starting a chaincode on the channel
#Openning a new terminal to input the following command:
cd /data/fabric/fabric-samples/test-network

#The following instruction need GO to be installed.
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go

#The following instruction need node.js to be installed.
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript -ccl javascript

#The following instruction need java to be installed.
<!-- Not need:
#Setting the proxy to download gradle-7.3.1-bin.zip. Or downloading maybe is very slow...
tee /data/fabric/fabric-samples/asset-transfer-basic/chaincode-java/gradle.properties <<-'EOF'
systemProp.http.proxyHost=192.168.102.82
systemProp.http.proxyPort=1082
systemProp.https.proxyHost=192.168.102.82
systemProp.https.proxyPort=1082
systemProp.http.nonProxyHosts=192.*|172.*|127.*|localhost
EOF -->
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-java -ccl java
#Don't use the proxy to build, Or you will encouter the following errors:
Error: chaincode install failed with status: 500 - error in simulation: failed to execute transaction c6d2553ed5f14fa4336438c686f538730f90f51bf1c5737f60c0cd3f0e17561a: error sending: timeout expired while executing transaction

# Interacting with the network

cd /data/fabric/fabric-samples/test-network
export PATH=${PWD}/../bin:$PATH
export FABRIC_CFG_PATH=$PWD/../config/

#You can now set the environment variables that allow you to operate the peer CLI as Org1:
#Environment variables for Org1
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051

#Run the following command to initialize the ledger with assets.
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"InitLedger","Args":[]}'

#You can now query the ledger from your CLI. Run the following command to get the list of assets that were added to your channel ledger:
peer chaincode query -C mychannel -n basic -c '{"Args":["GetAllAssets"]}' | prettyjson

#Use the following command to change the owner of an asset on the ledger by invoking the asset-transfer (basic) chaincode:
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"TransferAsset","Args":["asset6","Christopher"]}'

#Set the following environment variables to operate as Org2:
#Environment variables for Org2
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
export CORE_PEER_ADDRESS=localhost:9051

#You can now query the asset-transfer (basic) chaincode running on peer0.org2.example.com:
peer chaincode query -C mychannel -n basic -c '{"Args":["ReadAsset","asset6"]}'

#Bring down the network
./network.sh down
#relogin to take effect from trying again.
<!-- docker rm -f $(docker ps -aq)
docker rmi -f $(docker images -q)
docker rmi -f $(docker images | grep dev-peer[0-9] | awk '{print $3}') -->

# Deploying a smart contract to a channel

## Package the smart contract
#GO
cd /data/fabric/fabric-samples/test-network
export PATH=${PWD}/../bin:$PATH
export FABRIC_CFG_PATH=$PWD/../config/
peer version
#You can now create the chaincode package using the peer lifecycle chaincode package command:
peer lifecycle chaincode package basic.tar.gz --path ../asset-transfer-basic/chaincode-go/ --lang golang --label basic_1.0

## Install the chaincode package

both Org1 and org2

#We can now install the chaincode on the Org1 peer
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051

peer lifecycle chaincode install basic.tar.gz

#We can now install the chaincode on the Org2 peer
export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
export CORE_PEER_ADDRESS=localhost:9051

peer lifecycle chaincode install basic.tar.gz

## Approve a chaincode definition

both Org1 and org2

#You can find the package ID of a chaincode by using the peer lifecycle chaincode queryinstalled command to query your peer
peer lifecycle chaincode queryinstalled

#let’s go ahead and save it as an environment variable. Paste the package ID returned by peer lifecycle chaincode queryinstalled into the command below
export CC_PACKAGE_ID=basic_1.0:2e20ce421c8037420718c8a3918a1eea76343b7361fffdac454181c54e5736c7

#Chaincode is approved at the organization level, so the command only needs to target one peer. The approval is distributed to the other peers within the organization using gossip. Approve the chaincode definition using the peer lifecycle chaincode approveformyorg command:

peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"


#We still need to approve the chaincode definition as Org1
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_ADDRESS=localhost:7051

peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"

#We now have the majority we need to deploy the asset-transfer (basic) the chaincode to the channel. 

## Committing the chaincode definition to the channel

"peer lifecycle chaincode commit" need to imply the both of peers of Org1 and Org2:
--peerAddresses localhost:7051
--peerAddresses localhost:9051 


#After a sufficient number of organizations have approved a chaincode definition, one organization can commit the chaincode definition to the channel
You can use the peer lifecycle chaincode checkcommitreadiness command to check whether channel members have approved the same chaincode definition

peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" --output json

#You can use the peer lifecycle chaincode commit command to commit the chaincode definition to the channel. The commit command also needs to be submitted by an organization admin.

peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt"

#You can use the peer lifecycle chaincode querycommitted command to confirm that the chaincode definition has been committed to the channel.

peer lifecycle chaincode querycommitted --channelID mychannel --name basic --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"


## Invoking the chaincode

#Use the following command to create an initial set of assets on the ledger. Note the CLI does not access the Fabric Gateway peer, so each endorsing peer must be specified.

peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"InitLedger","Args":[]}'

#We can use a query function to read the set of cars that were created by the chaincode:

peer chaincode query -C mychannel -n basic -c '{"Args":["GetAllAssets"]}' | prettyjson

## Upgrading a smart contract

#Openning a new terminal to input the following command:
cd /data/fabric/fabric-samples/asset-transfer-basic/chaincode-javascript
npm install
cd ../../test-network
export PATH=${PWD}/../bin:$PATH
export FABRIC_CFG_PATH=$PWD/../config/

#You can then issue the following commands to package the JavaScript chaincode from the test-network directory. We will set the environment variables needed to use the peer CLI again in case you closed your terminal.

export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
peer lifecycle chaincode package basic_2.tar.gz --path ../asset-transfer-basic/chaincode-javascript/ --lang node --label basic_2.0

#Run the following commands to operate the peer CLI as the Org1 admin:

export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051

#https://charlielin.top/2020/03/26/%E5%9C%A8-fabric-%E4%B8%8A%E6%89%A7%E8%A1%8C-chaincode-%E7%9A%84%E6%A2%B3%E7%90%86/
#We can now use the following command to install the new chaincode package on the Org1 peer.
#It much more slower than installing go, which needs a few seconds to be installed, just wait with patient:
peer lifecycle chaincode install basic_2.tar.gz
peer lifecycle chaincode queryinstalled

#ou can use the package label to find the package ID of the new chaincode and save it as a new environment variable. This output is for example only – your package ID will be different, so DO NOT COPY AND PASTE!
export NEW_CC_PACKAGE_ID=basic_2.0:65dc35f2a2bfc653fc329254b5e0ab2646b4fd65f7613f7772d9954da064a224

#Org1 can now approve a new chaincode definition:
#Because the sequence parameter is used by the Fabric chaincode lifecycle to keep track of chaincode upgrades, Org1 also needs to increment the sequence number from 1 to 2
peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --package-id $NEW_CC_PACKAGE_ID --sequence 2 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"


#We now need to install the chaincode package and approve the chaincode definition as Org2 in order to upgrade the chaincode. 

export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
export CORE_PEER_ADDRESS=localhost:9051

#We can now use the following command to install the new chaincode package on the Org2 peer.
peer lifecycle chaincode install basic_2.tar.gz

#You can now approve the new chaincode definition for Org2.

peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --package-id $NEW_CC_PACKAGE_ID --sequence 2 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"

#check if the chaincode definition with sequence 2 is ready to be committed to the channel:

peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 2.0 --sequence 2 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" --output json

#Org2 can use the following command to upgrade the chaincode:

peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --sequence 2 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt"


#we can test our new JavaScript chaincode by creating a new car:

peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"CreateAsset","Args":["asset8","blue","16","Kelley","750"]}'


#Clean up

docker stop logspout
docker rm logspout
cd /data/fabric/fabric-samples/test-network
./network.sh down


# Running a Fabric Application

## Set up the blockchain network

./network.sh up createChannel -c mychannel -ca


## Deploy the smart contract

./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-typescript/ -ccl typescript


## Prepare the sample application

cd ../asset-transfer-basic/application-gateway-typescript
apt install -y make g++
npm install
npm run-script build
npm start

# Running chaincode in development mode

## Set up environment
#git clone https://github.com/hyperledger/fabric
apt install -y make g++
cp -a /vagrant/fabric /Developer/
cd /Developer/fabric
make orderer peer configtxgen

export PATH=$(pwd)/build/bin:$PATH
export FABRIC_CFG_PATH=$(pwd)/sampleconfig
sudo mkdir /var/hyperledger
configtxgen -profile SampleDevModeSolo -channelID syschannel -outputBlock genesisblock -configPath $FABRIC_CFG_PATH -outputBlock "$(pwd)/sampleconfig/genesisblock"

## Start the orderer

ORDERER_GENERAL_GENESISPROFILE=SampleDevModeSolo orderer

## Start the peer in DevMode

#Open another terminal window and set the required environment variables to override the peer configuration and start the peer node:
cd /Developer/fabric
export CORE_OPERATIONS_LISTENADDRESS=127.0.0.1:9444
export PATH=$(pwd)/build/bin:$PATH
export FABRIC_CFG_PATH=$(pwd)/sampleconfig
FABRIC_LOGGING_SPEC=chaincode=debug CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052 peer node start --peer-chaincodedev=true

## Create channel and join peer

#Open another terminal window

cd /Developer/fabric
export PATH=$(pwd)/build/bin:$PATH
export FABRIC_CFG_PATH=$(pwd)/sampleconfig
configtxgen -channelID ch1 -outputCreateChannelTx ch1.tx -profile SampleSingleMSPChannel -configPath $FABRIC_CFG_PATH
peer channel create -o 127.0.0.1:7050 -c ch1 -f ch1.tx
peer channel join -b ch1.block

## Build the chaincode

cd /Developer/fabric
go build -o simpleChaincode ./integration/chaincode/simple/cmd

## Start the chaincode

CORE_CHAINCODE_LOGLEVEL=debug CORE_PEER_TLS_ENABLED=false CORE_CHAINCODE_ID_NAME=mycc:1.0 ./simpleChaincode -peer.address 127.0.0.1:7052


## Approve and commit the chaincode definition

#Open another terminal window

cd /Developer/fabric
export PATH=$(pwd)/build/bin:$PATH
export FABRIC_CFG_PATH=$(pwd)/sampleconfig
peer lifecycle chaincode approveformyorg  -o 127.0.0.1:7050 --channelID ch1 --name mycc --version 1.0 --sequence 1 --init-required --signature-policy "OR ('SampleOrg.member')" --package-id mycc:1.0
peer lifecycle chaincode checkcommitreadiness -o 127.0.0.1:7050 --channelID ch1 --name mycc --version 1.0 --sequence 1 --init-required --signature-policy "OR ('SampleOrg.member')"
peer lifecycle chaincode commit -o 127.0.0.1:7050 --channelID ch1 --name mycc --version 1.0 --sequence 1 --init-required --signature-policy "OR ('SampleOrg.member')" --peerAddresses 127.0.0.1:7051

## Next steps

CORE_PEER_ADDRESS=127.0.0.1:7051 peer chaincode invoke -o 127.0.0.1:7050 -C ch1 -n mycc -c '{"Args":["init","a","100","b","200"]}' --isInit
CORE_PEER_ADDRESS=127.0.0.1:7051 peer chaincode invoke -o 127.0.0.1:7050 -C ch1 -n mycc -c '{"Args":["invoke","a","b","10"]}'
CORE_PEER_ADDRESS=127.0.0.1:7051 peer chaincode invoke -o 127.0.0.1:7050 -C ch1 -n mycc -c '{"Args":["query","a"]}'



















docker export 478bb473dc99 > docker_node1.tar
docker import docker_node1.tar dave/fabric:latest
docker run -d --name fabric --privileged=true dave/fabric:latest /sbin/init

exportImages.sh:
```bash
#!/bin/bash

for image in `docker images|grep hyperledger|awk '{print $1":"$2}'`
do
  tarname=${image#*/}.tar
  docker save -o /vagrant/hyperledger/$tarname $image
done
```

importImages.sh:
```bash
#!/bin/bash

for tar in `ls /vagrant/hyperledger`
do
  docker load -i /vagrant/hyperledger/$tar
done
```

fabric.sh:
```bash
#!/bin/bash

echo "140.82.112.4 github.com
185.199.110.133 raw.githubusercontent.com" >> /etc/hosts

apt-get -y install apt-transport-https ca-certificates software-properties-common
curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -
add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"
apt-get -y update
apt-get -y install docker-ce docker-ce-cli containerd.io docker-compose-plugin docker-compose

mkdir -p /etc/docker/
tee /etc/docker/daemon.json <<-'EOF'
{
  "dns" : [
     "8.8.4.4",
     "8.8.8.8",
     "114.114.114.114"
  ],
  "registry-mirrors": [
    "https://registry.docker-cn.com",
    "https://3laho3y3.mirror.aliyuncs.com",
    "http://hub-mirror.c.163.com"
  ]
}
EOF

mkdir -p /etc/systemd/system/docker.service.d
tee /etc/systemd/system/docker.service.d/http-proxy.conf <<-'EOF'
[Service]
Environment="HTTP_PROXY=http://192.168.102.82:1082"
Environment="HTTPS_PROXY=http://192.168.102.82:1082"
Environment="NO_PROXY=127.0.0.1,localhost,10.0.0.0/8,172.0.0.0/8,192.168.0.0/16,*.zerofinance.net,*.aliyun.com,*.163.com,*.docker-cn.com,kubernetes.docker.internal"
EOF

echo "export PATH=/data/fabric/go/bin:\$PATH" > /etc/profile.d/env.sh

. /etc/profile

echo "alias prettyjson=\"python3 -m json.tool\"
function proxy_off(){
    unset http_proxy
    unset https_proxy
    echo -e \"The proxy has been closed!\"
}
function proxy_on() {
    export no_proxy=\"127.0.0.1,localhost,10.0.0.0/8,172.0.0.0/8,192.168.0.0/16,*.zerofinance.net,*.aliyun.com,*.163.com,*.docker-cn.com,registry.gcalls.cn\"
    export http_proxy=\"http://192.168.102.82:1082\"
    export https_proxy=\$http_proxy
    echo -e \"The proxy has been opened!\"
}" >> ~/.bashrc 

. ~/.bashrc
```

java.sh:
```bash
#!/bin/bash

mkdir -p /Developer/java/
tar zxf jdk-8u202-linux-x64.tar.gz -C /Developer/java/

tee /etc/profile.d/java.sh <<-'EOF'
export JAVA_HOME=/Developer/java/jdk1.8.0_202
export GRADLE_USER_HOME=/Developer/.gradle
export PATH=$JAVA_HOME/bin:$PATH
EOF

source /etc/profile
```

nodejs.sh:
```bash
#!/bin/bash

export http_proxy=http://192.168.102.82:1082
export https_proxy=http://192.168.102.82:1082
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
. ~/.bashrc


export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

nvm install v14.19.3
npm config set registry https://registry.npmmirror.com --global
npm config set disturl https://npmmirror.com/dist --global
```


restart the docker container to take docker proxy affect:
```bash
vagrant reload
```


./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-typescript/ -ccl typescript
Using docker and docker-compose
deploying chaincode on channel 'mychannel'
executing with the following
- CHANNEL_NAME: mychannel
- CC_NAME: basic
- CC_SRC_PATH: ../asset-transfer-basic/chaincode-typescript/
- CC_SRC_LANGUAGE: typescript
- CC_VERSION: 1.0
- CC_SEQUENCE: 1
- CC_END_POLICY: NA
- CC_COLL_CONFIG: NA
- CC_INIT_FCN: NA
- DELAY: 3
- MAX_RETRY: 5
- VERBOSE: false
Compiling TypeScript code into JavaScript...
/data/fabric/fabric-samples/asset-transfer-basic/chaincode-typescript /data/fabric/fabric-samples/test-network
npm WARN read-shrinkwrap This version of npm is compatible with lockfileVersion@1, but npm-shrinkwrap.json was generated for lockfileVersion@2. I'll try to do my best with it!

> protobufjs@6.11.2 postinstall /data/fabric/fabric-samples/asset-transfer-basic/chaincode-typescript/node_modules/protobufjs
> node scripts/postinstall

npm WARN asset-transfer-basic@1.0.0 No repository field.

added 285 packages from 1007 contributors in 23.636s

10 packages are looking for funding
  run `npm fund` for details


> asset-transfer-basic@1.0.0 build /data/fabric/fabric-samples/asset-transfer-basic/chaincode-typescript
> tsc

/data/fabric/fabric-samples/test-network
Finished compiling TypeScript code into JavaScript
+ peer lifecycle chaincode package basic.tar.gz --path ../asset-transfer-basic/chaincode-typescript/ --lang node --label basic_1.0
+ res=0
Chaincode is packaged
Installing chaincode on peer0.org1...
Using organization 1
+ peer lifecycle chaincode install basic.tar.gz
+ res=0
2022-05-26 04:26:57.130 UTC 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -> Installed remotely: response:<status:200 payload:"\nJbasic_1.0:a2a8ca3eb018ae99360eb2d0d6dbb6ebe142c44d15f9c8f274eb52e5693d63e0\022\tbasic_1.0" > 
2022-05-26 04:26:57.130 UTC 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -> Chaincode code package identifier: basic_1.0:a2a8ca3eb018ae99360eb2d0d6dbb6ebe142c44d15f9c8f274eb52e5693d63e0
Chaincode is installed on peer0.org1
Install chaincode on peer0.org2...
Using organization 2
+ peer lifecycle chaincode install basic.tar.gz
+ res=0
2022-05-26 04:27:04.292 UTC 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -> Installed remotely: response:<status:200 payload:"\nJbasic_1.0:a2a8ca3eb018ae99360eb2d0d6dbb6ebe142c44d15f9c8f274eb52e5693d63e0\022\tbasic_1.0" > 
2022-05-26 04:27:04.292 UTC 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -> Chaincode code package identifier: basic_1.0:a2a8ca3eb018ae99360eb2d0d6dbb6ebe142c44d15f9c8f274eb52e5693d63e0
Chaincode is installed on peer0.org2
Using organization 1
+ peer lifecycle chaincode queryinstalled
+ res=0
Installed chaincodes on peer:
Package ID: basic_1.0:a2a8ca3eb018ae99360eb2d0d6dbb6ebe142c44d15f9c8f274eb52e5693d63e0, Label: basic_1.0
Query installed successful on peer0.org1 on channel
Using organization 1
+ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile /data/fabric/fabric-samples/test-network/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem --channelID mychannel --name basic --version 1.0 --package-id basic_1.0:a2a8ca3eb018ae99360eb2d0d6dbb6ebe142c44d15f9c8f274eb52e5693d63e0 --sequence 1
+ res=0
2022-05-26 04:27:06.358 UTC 0001 INFO [chaincodeCmd] ClientWait -> txid [6c24bc1c12650e28af12604b9cc0d4fca89ca82b4cff2375dc1c550ba60998fa] committed with status (VALID) at localhost:7051
Chaincode definition approved on peer0.org1 on channel 'mychannel'
Using organization 1
Checking the commit readiness of the chaincode definition on peer0.org1 on channel 'mychannel'...
Attempting to check the commit readiness of the chaincode definition on peer0.org1, Retry after 3 seconds.
+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --output json
+ res=0
{
	"approvals": {
		"Org1MSP": true,
		"Org2MSP": false
	}
}
Checking the commit readiness of the chaincode definition successful on peer0.org1 on channel 'mychannel'
Using organization 2
Checking the commit readiness of the chaincode definition on peer0.org2 on channel 'mychannel'...
Attempting to check the commit readiness of the chaincode definition on peer0.org2, Retry after 3 seconds.
+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --output json
+ res=0
{
	"approvals": {
		"Org1MSP": true,
		"Org2MSP": false
	}
}
Checking the commit readiness of the chaincode definition successful on peer0.org2 on channel 'mychannel'
Using organization 2
+ peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile /data/fabric/fabric-samples/test-network/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem --channelID mychannel --name basic --version 1.0 --package-id basic_1.0:a2a8ca3eb018ae99360eb2d0d6dbb6ebe142c44d15f9c8f274eb52e5693d63e0 --sequence 1
+ res=0
2022-05-26 04:27:14.466 UTC 0001 INFO [chaincodeCmd] ClientWait -> txid [cbc43c393482cac0d32b638bd6395e8926ff4e424de1a8c6a1afdf433e164ffd] committed with status (VALID) at localhost:9051
Chaincode definition approved on peer0.org2 on channel 'mychannel'
Using organization 1
Checking the commit readiness of the chaincode definition on peer0.org1 on channel 'mychannel'...
Attempting to check the commit readiness of the chaincode definition on peer0.org1, Retry after 3 seconds.
+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --output json
+ res=0
{
	"approvals": {
		"Org1MSP": true,
		"Org2MSP": true
	}
}
Checking the commit readiness of the chaincode definition successful on peer0.org1 on channel 'mychannel'
Using organization 2
Checking the commit readiness of the chaincode definition on peer0.org2 on channel 'mychannel'...
Attempting to check the commit readiness of the chaincode definition on peer0.org2, Retry after 3 seconds.
+ peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --output json
+ res=0
{
	"approvals": {
		"Org1MSP": true,
		"Org2MSP": true
	}
}
Checking the commit readiness of the chaincode definition successful on peer0.org2 on channel 'mychannel'
Using organization 1
Using organization 2
+ peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile /data/fabric/fabric-samples/test-network/organizations/ordererOrganizations/example.com/tlsca/tlsca.example.com-cert.pem --channelID mychannel --name basic --peerAddresses localhost:7051 --tlsRootCertFiles /data/fabric/fabric-samples/test-network/organizations/peerOrganizations/org1.example.com/tlsca/tlsca.org1.example.com-cert.pem --peerAddresses localhost:9051 --tlsRootCertFiles /data/fabric/fabric-samples/test-network/organizations/peerOrganizations/org2.example.com/tlsca/tlsca.org2.example.com-cert.pem --version 1.0 --sequence 1
+ res=0
2022-05-26 04:27:22.575 UTC 0002 INFO [chaincodeCmd] ClientWait -> txid [8d452d2f28aa6ac80dbe3e2f8ce894130e0019a24143a2e167f749d4a8fa494b] committed with status (VALID) at localhost:7051
2022-05-26 04:27:22.575 UTC 0001 INFO [chaincodeCmd] ClientWait -> txid [8d452d2f28aa6ac80dbe3e2f8ce894130e0019a24143a2e167f749d4a8fa494b] committed with status (VALID) at localhost:9051
Chaincode definition committed on channel 'mychannel'
Using organization 1
Querying chaincode definition on peer0.org1 on channel 'mychannel'...
Attempting to Query committed status on peer0.org1, Retry after 3 seconds.
+ peer lifecycle chaincode querycommitted --channelID mychannel --name basic
+ res=0
Committed chaincode definition for chaincode 'basic' on channel 'mychannel':
Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]
Query chaincode definition successful on peer0.org1 on channel 'mychannel'
Using organization 2
Querying chaincode definition on peer0.org2 on channel 'mychannel'...
Attempting to Query committed status on peer0.org2, Retry after 3 seconds.
+ peer lifecycle chaincode querycommitted --channelID mychannel --name basic
+ res=0
Committed chaincode definition for chaincode 'basic' on channel 'mychannel':
Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]
Query chaincode definition successful on peer0.org2 on channel 'mychannel'
Chaincode initialization is not required