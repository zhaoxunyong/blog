学习计划：
seata
hadoop/flink/spark/hive
GraphQL
DDD --- 学习中
minio/seaweedfs
spring alibaba cloud---xxx

serverless/istio ---ok
React(icejs/antd) ---ok
MyBatis-Plus(dynamic-datasource) ---ok
Kubernetes---ok
spring cloud kubernetes---ok
kylin---ok
rocketmq---ok
中台架构与实现 ---ok

书籍学习：
支付平台架构
精通以太坊
超大系统分布式流量解决方案
云原生应用管理
istio服务网格技术解析与实践
领域驱动设计: 学习中
微服务设计模式

其他学习：
已经购买的一些学习视频（极客）

微信公众号学习：
Java架构师之路
架构师之路
高可用架构
Java后端技术
程序员DD
阿里技术
云时代架构
51CTO技术栈
淘系技术
大数据云技术

-------------------------------------------------


培训计划：
1. java单元测试与集成测试培训 --- ok
2. 领域驱动设计(DDD)系列一 --- ok
3. 领域驱动设计(DDD)系列二 ---ok
4. kubernetes istio培训
5. eclipse与vscode插件开发
6. SaaS多租户平台架构设计讲解
7. Jenkins构建与代码质量检测
8. kubernetes系列课程之二


Step 1:
rm -fr /data/var-lib-docker/
cd /data/vagrant/docker
vagrant destroy node1 -f
vagrant up node1
#Entering the container:
docker exec -it `docker ps|grep node1|awk '{print $1}'` bash
cd /vagrant/
./changpwd.sh


./fabric.sh
#Optional, only for deploying javascript chaincode
./nodejs.sh
source ~/.bashrc
#Optional, only for deploying java chaincode
./java.sh
source /etc/profile
./importImages.sh


<!-- Step 1: From scratch
apt install -y docker-compose
vim /etc/profile.d/env.sh
export PATH=/data/fabric/go/bin:$PATH

. /etc/profile

#The following installation just only from developing chaincode by javascript:
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
. ~/.bashrc
#显示有远端的版本
nvm ls-remote
#安装对应的版本
nvm install v12.22.6
npm config set registry https://registry.npmmirror.com --global
npm config set disturl https://npmmirror.com/dist --global
#npm install yarn -g
#npm install http-server -g

#yarn config set registry https://registry.npmmirror.com --global
#yarn config set disturl https://npmmirror.com/dist --global
#yarn global add serve

#The following installation just only from developing chaincode by java:

#https://hyperledger-fabric.readthedocs.io/en/latest/install.html
apt install -y docker-compose
cd /data/fabric
curl -sSLO https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/install-fabric.sh && chmod +x install-fabric.sh
proxy_on
./install-fabric.sh --fabric-version 2.4.3 docker
./install-fabric.sh --fabric-version 2.4.3 binary
./install-fabric.sh --fabric-version 2.4.3 samples

proxy_off
mv bin config fabric-samples/
cd /data/fabric/fabric-samples/test-network -->

<!-- #For second time:
apt install docker-compose
mkdir -p /data/
ln -s /vagrant/fabric /data/fabric
cd /data/fabric
./install-fabric.sh --fabric-version 2.4.3 docker -->

Step 2:
#https://hyperledger-fabric.readthedocs.io/en/latest/test_network.html

# Starting a chaincode on the channel
#Openning a new terminal to input the following command:
cd /data/fabric/fabric-samples/test-network
<!-- ./network.sh up 
#Creating a channel
./network.sh createChannel -->
./network.sh up createChannel
#Monitor:
./monitordocker.sh fabric_test

# Starting a chaincode on the channel
#Openning a new terminal to input the following command:
cd /data/fabric/fabric-samples/test-network

#The following instruction need GO to be installed.
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go

#The following instruction need node.js to be installed.
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript -ccl javascript

#The following instruction need java to be installed.
<!-- Not need:
#Setting the proxy to download gradle-7.3.1-bin.zip. Or downloading maybe is very slow...
tee /data/fabric/fabric-samples/asset-transfer-basic/chaincode-java/gradle.properties <<-'EOF'
systemProp.http.proxyHost=192.168.102.82
systemProp.http.proxyPort=1082
systemProp.https.proxyHost=192.168.102.82
systemProp.https.proxyPort=1082
systemProp.http.nonProxyHosts=192.*|172.*|127.*|localhost
EOF -->
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-java -ccl java
#Encoutering the following errors by java, couldn't resolve anyway:
Error: chaincode install failed with status: 500 - error in simulation: failed to execute transaction c6d2553ed5f14fa4336438c686f538730f90f51bf1c5737f60c0cd3f0e17561a: error sending: timeout expired while executing transaction

# Interacting with the network

cd /data/fabric/fabric-samples/test-network
export PATH=${PWD}/../bin:$PATH
export FABRIC_CFG_PATH=$PWD/../config/

#You can now set the environment variables that allow you to operate the peer CLI as Org1:
#Environment variables for Org1
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051

#Run the following command to initialize the ledger with assets.
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"InitLedger","Args":[]}'

#You can now query the ledger from your CLI. Run the following command to get the list of assets that were added to your channel ledger:
peer chaincode query -C mychannel -n basic -c '{"Args":["GetAllAssets"]}' | prettyjson

#Use the following command to change the owner of an asset on the ledger by invoking the asset-transfer (basic) chaincode:
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"TransferAsset","Args":["asset6","Christopher"]}'

#Set the following environment variables to operate as Org2:
#Environment variables for Org2
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
export CORE_PEER_ADDRESS=localhost:9051

#You can now query the asset-transfer (basic) chaincode running on peer0.org2.example.com:
peer chaincode query -C mychannel -n basic -c '{"Args":["ReadAsset","asset6"]}'

#Bring down the network
./network.sh down
#relogin to take effect from trying again.
<!-- docker rm -f $(docker ps -aq)
docker rmi -f $(docker images -q)
docker rmi -f $(docker images | grep dev-peer[0-9] | awk '{print $3}') -->

# Deploying a smart contract to a channel

## Package the smart contract
#GO
cd /data/fabric/fabric-samples/test-network
export PATH=${PWD}/../bin:$PATH
export FABRIC_CFG_PATH=$PWD/../config/
peer version
#You can now create the chaincode package using the peer lifecycle chaincode package command:
peer lifecycle chaincode package basic.tar.gz --path ../asset-transfer-basic/chaincode-go/ --lang golang --label basic_1.0

## Install the chaincode package

#We can now install the chaincode on the Org1 peer
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051

peer lifecycle chaincode install basic.tar.gz

#We can now install the chaincode on the Org2 peer
export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
export CORE_PEER_ADDRESS=localhost:9051

peer lifecycle chaincode install basic.tar.gz

## Approve a chaincode definition

#You can find the package ID of a chaincode by using the peer lifecycle chaincode queryinstalled command to query your peer
peer lifecycle chaincode queryinstalled

#let’s go ahead and save it as an environment variable. Paste the package ID returned by peer lifecycle chaincode queryinstalled into the command below
export CC_PACKAGE_ID=basic_1.0:2e20ce421c8037420718c8a3918a1eea76343b7361fffdac454181c54e5736c7

#Chaincode is approved at the organization level, so the command only needs to target one peer. The approval is distributed to the other peers within the organization using gossip. Approve the chaincode definition using the peer lifecycle chaincode approveformyorg command:

peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"


#We still need to approve the chaincode definition as Org1
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_ADDRESS=localhost:7051

peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC_PACKAGE_ID --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"

#We now have the majority we need to deploy the asset-transfer (basic) the chaincode to the channel. 

## Committing the chaincode definition to the channel

#After a sufficient number of organizations have approved a chaincode definition, one organization can commit the chaincode definition to the channel
You can use the peer lifecycle chaincode checkcommitreadiness command to check whether channel members have approved the same chaincode definition

peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" --output json

#You can use the peer lifecycle chaincode commit command to commit the chaincode definition to the channel. The commit command also needs to be submitted by an organization admin.

peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt"

#You can use the peer lifecycle chaincode querycommitted command to confirm that the chaincode definition has been committed to the channel.

peer lifecycle chaincode querycommitted --channelID mychannel --name basic --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem"


## Invoking the chaincode

#Use the following command to create an initial set of assets on the ledger. Note the CLI does not access the Fabric Gateway peer, so each endorsing peer must be specified.

peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile "${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem" -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt" --peerAddresses localhost:9051 --tlsRootCertFiles "${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt" -c '{"function":"InitLedger","Args":[]}'

#We can use a query function to read the set of cars that were created by the chaincode:

peer chaincode query -C mychannel -n basic -c '{"Args":["GetAllAssets"]}' | prettyjson

## Upgrading a smart contract

#Openning a new terminal to input the following command:
cd /data/fabric/fabric-samples/asset-transfer-basic/chaincode-javascript
npm install
cd ../../test-network

#You can then issue the following commands to package the JavaScript chaincode from the test-network directory. We will set the environment variables needed to use the peer CLI again in case you closed your terminal.

#Run the following commands to operate the peer CLI as the Org1 admin:

export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051

#https://charlielin.top/2020/03/26/%E5%9C%A8-fabric-%E4%B8%8A%E6%89%A7%E8%A1%8C-chaincode-%E7%9A%84%E6%A2%B3%E7%90%86/
#We can now use the following command to install the new chaincode package on the Org1 peer.
#It much more slower than installing go, which needs a few seconds to be installed, just wait with patient:
peer lifecycle chaincode install basic_2.tar.gz
peer lifecycle chaincode queryinstalled







docker export 478bb473dc99 > docker_node1.tar
docker import docker_node1.tar dave/fabric:latest
docker run -d --name fabric --privileged=true dave/fabric:latest /sbin/init

exportImages.sh:
```bash
#!/bin/bash

for image in `docker images|grep hyperledger|awk '{print $1":"$2}'`
do
  tarname=${image#*/}.tar
  docker save -o /vagrant/hyperledger/$tarname $image
done
```

importImages.sh:
```bash
#!/bin/bash

for tar in `ls /vagrant/hyperledger`
do
  docker load -i /vagrant/hyperledger/$tar
done
```

fabric.sh:
```bash
#!/bin/bash

echo "140.82.112.4 github.com
185.199.110.133 raw.githubusercontent.com" >> /etc/hosts

apt-get -y install apt-transport-https ca-certificates software-properties-common
curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -
add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"
apt-get -y update
apt-get -y install docker-ce docker-ce-cli containerd.io docker-compose-plugin docker-compose

mkdir -p /etc/docker/
tee /etc/docker/daemon.json <<-'EOF'
{
  "dns" : [
     "8.8.4.4",
     "8.8.8.8",
     "114.114.114.114"
  ],
  "registry-mirrors": [
    "https://registry.docker-cn.com",
    "https://3laho3y3.mirror.aliyuncs.com",
    "http://hub-mirror.c.163.com"
  ]
}
EOF

mkdir -p /etc/systemd/system/docker.service.d
tee /etc/systemd/system/docker.service.d/http-proxy.conf <<-'EOF'
[Service]
Environment="HTTP_PROXY=http://192.168.102.82:1082"
Environment="HTTPS_PROXY=http://192.168.102.82:1082"
Environment="NO_PROXY=127.0.0.1,localhost,10.0.0.0/8,172.0.0.0/8,192.168.0.0/16,*.zerofinance.net,*.aliyun.com,*.163.com,*.docker-cn.com,kubernetes.docker.internal"
EOF

echo "export PATH=/data/fabric/go/bin:\$PATH" > /etc/profile.d/env.sh

. /etc/profile

echo "alias prettyjson=\"python3 -m json.tool\"
function proxy_off(){
    unset http_proxy
    unset https_proxy
    echo -e \"The proxy has been closed!\"
}
function proxy_on() {
    export no_proxy=\"127.0.0.1,localhost,10.0.0.0/8,172.0.0.0/8,192.168.0.0/16,*.zerofinance.net,*.aliyun.com,*.163.com,*.docker-cn.com,registry.gcalls.cn\"
    export http_proxy=\"http://192.168.102.82:1082\"
    export https_proxy=\$http_proxy
    echo -e \"The proxy has been opened!\"
}" >> ~/.bashrc 

. ~/.bashrc
```

java.sh:
```bash
#!/bin/bash

mkdir -p /Developer/java/
tar zxf jdk-8u202-linux-x64.tar.gz -C /Developer/java/

tee /etc/profile.d/java.sh <<-'EOF'
export JAVA_HOME=/Developer/java/jdk1.8.0_202
export GRADLE_USER_HOME=/Developer/.gradle
export PATH=$JAVA_HOME/bin:$PATH
EOF

source /etc/profile
```

nodejs.sh:
```bash
#!/bin/bash

export http_proxy=http://192.168.102.82:1082
export https_proxy=http://192.168.102.82:1082
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash
. ~/.bashrc


export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

nvm install v12.22.6
npm config set registry https://registry.npmmirror.com --global
npm config set disturl https://npmmirror.com/dist --global
```


restart the docker container to take docker proxy affect:
```bash
vagrant reload
```