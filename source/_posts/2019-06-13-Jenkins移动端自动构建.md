---
title: Jenkins移动端自动构建
date: 2019-06-13 16:46:34
tags: ["app"]
toc: true
---

记录一下jenkins自动构建android与ios安装包。

<!-- more -->

## 安装

由于需要构建ios，所以安装在mac电脑中。安装时记得勾选gradle插件。网上很多安装方式，此处不再重复。

## 系统配置

没有采用jenkins插件方式安装，而是通过命令行shell脚本直接运行，所以需要事先在这台电脑上安装好相关的环境，并确保手动构建、打包功能正常。

android gradle配置：

```bash
ext {
    defaultIsJenkins = "false"
    isJenkins = project.hasProperty('IS_JENKINS') ? IS_JENKINS : defaultIsJenkins
}
def loadSigningConfig() {
    if ("true".equals(isJenkins)) {
        // Create a variable called keystorePropertiesFile, and initialize it to your
        // keystore.properties file, in the rootProject folder.
        def keystorePropertiesFile = rootProject.file("/Users/test/.jenkins/scripts/signingConfigs.properties")
        // Initialize a new Properties() object called keystoreProperties.
        def keystoreProperties = new Properties()
        // Load your keystore.properties file into the keystoreProperties object.
        keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
        android.signingConfigs.config.keyAlias = keystoreProperties['keyAlias']
        android.signingConfigs.config.keyPassword = keystoreProperties['keyPassword']
        android.signingConfigs.config.storeFile = file(keystoreProperties['storeFile'])
        android.signingConfigs.config.storePassword = keystoreProperties['storePassword']
    }
}

android {
    ...

    signingConfigs {
        config {
        }
    }
    loadSigningConfig()

    defaultConfig {
        ...
        versionCode rootProject.ext.versionCode
        versionName rootProject.ext.versionName
        ...
    }
    ...

    buildTypes {
        release {
            ...
            if ("true".equals(isJenkins)) {
                signingConfig signingConfigs.config
            }
        }
        debug {
            if ("true".equals(isJenkins)) {
                signingConfig signingConfigs.config
            }
        }
    }

    applicationVariants.all { variant ->
        variant.outputs.all { output ->
            if ("true".equals(isJenkins)) {
                outputFileName = new File("xwallet-"+rootProject.ext.versionName+"."+rootProject.ext.versionCode + "-"+BUILD_TYPE+".apk")
            }
            ...
        }
    }

```

## 应用发布平台

采用fabu.love开源平台，可以内网部署。

```bash
git clone https://github.com/HeadingMobile/fabu.love.git /opt/fabu.love
cd /opt/fabu.love/docker
```

源码修改(将更新时间显示为时分秒)：

client/src/components/appDetail/appVersions.vue:

```js
getCreatTime(date) {
  console.log(date)
  let releaseDate = new Date(date)  
  return `${releaseDate.getFullYear()}-${releaseDate.getMonth() + 1}-${releaseDate.getDate()} ${releaseDate.getHours()}:${releaseDate.getMinutes()}:${releaseDate.getSeconds()}`
}
```

client/src/components/appDetail/appPreView.vue:

```js
this.appVersionInfo.creatDateStr = `${releaseDate.getFullYear()}-${releaseDate.getMonth() + 1}-${releaseDate.getDate()} ${releaseDate.getHours()}:${releaseDate.getMinutes()}:${releaseDate.getSeconds()}`
```

运行之前记得修改docker-compose.yml下的配置:

```yml
  server:
    build:
      context: ../
      dockerfile: docker/Dockerfile
    environment:
      FABU_DB_HOST: mongo
      FABU_BASE_URL: https://www.xx.com
      FABU_UPLOAD_DIR: /fabu/upload
      FABU_EMAIL_SERVICE: smtp.xx.com
      FABU_EMAIL_USER: xxx
      FABU_EMAIL_PASS: xxx
      FABU_EMAIL_PORT: 465
```

注意：FABU_BASE_URL只能用https并且为443端口，否则ios无法安装。

运行：

```bash
docker-compose up -d --build
```

重新安装时，只不要删除目录下的data目录，原来的数据则还在。

## nginx配置

```config
server {
  listen 443;
  server_name  www.xx.com;
  server_tokens off; 
  client_max_body_size 0;

  charset utf-8;  
  
  ssl on;
  ssl_certificate      /etc/nginx/xxx.crt;
  ssl_certificate_key  /etc/nginx/xxx.key;
  ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers ECDH:AESGCM:HIGH:!RC4:!DH:!MD5:!aNULL:!eNULL;

  ## Individual nginx logs for this GitLab vhost
  access_log  /var/log/nginx/www_access.log main;
  error_log   /var/log/nginx/www_error.log;

  location / { 
    #deny all;
    proxy_pass http://127.0.0.1:9898;
  }
}
```

## jenkins配置

Build->Execute shell:

```bash
if [[ "$GIT_BRANCH" == "" || "$BUILD_TYPE" == "" || "$PLATFORM" == "" || "$ENV" == "" ]]; then
  echo "Parameters must not be empty!"
  exit -1
else
  bash ${JENKINS_HOME}/scripts/buildApp.sh ${BUILD_TYPE} ${PLATFORM}
fi
```

[参考脚本](/files/jenkins_app_scripts.zip):

```bash
#!/bin/bash

source /Users/test/.bash_profile

BUILD_TYPE=$1
BUILD_PLATFORM=$2
WORKSPACE=$3
ENV=$4
GIT_BRANCH=$5

APP_NAME=xwallet
serverUrl=https://www.xxx.com
token=`curl -s -X POST "${serverUrl}/api/user/login" -H "accept: application/json" -H "Authorization: cabf435869e9bd4f24f8cbde9162531f" -H "content-type: application/json" -d "{ \"username\": \"zhaoxunyong\", \"password\": \"xxx\"}" | python -mjson.tool | grep token | awk -F'[:"]' '{print $5}'`

if [[ "$token" == "" ]]; then
    echo "Login failure."
    return -1
fi

teamId=`curl -s -X GET ${serverUrl}/api/user/teams -H "accept: application/json" -H "Authorization: Bearer ${token}" | python -mjson.tool | grep _id | awk -F'[:"]' '{print $5}' | head -1`
    

function deleteMaxApp() {
  platform=$1
  currentAppIdFile=${JENKINS_HOME}/scripts/currentAppId_${APP_NAME}_${platform}_uat
  appId=`cat ${currentAppIdFile}`
  echo "appId======${appId}"
  if [[ "$appId" != "" ]]; then
    currentVersions=(`curl -s -X GET "${serverUrl}/api/apps/${teamId}/${appId}/versions?page=0&size=9999" \
      -H "accept: application/json" \
      -H "Authorization: Bearer ${token}" \
      | python -mjson.tool | egrep "_id|versionCode" |tail -n 2 | awk -F'[:"]' '{print $5}'`)
    
    versionId=${currentVersions[0]}
    versionCode=${currentVersions[1]}

    curl -X DELETE "${serverUrl}/api/apps/${teamId}/${appId}/versions/${versionId}" \
      -H "accept: application/json" \
      -H "Authorization: Bearer ${token}"
  fi
}

function uploadApp() {
  platform=$1
  filePath=$2
  currentAppIdFile=${JENKINS_HOME}/scripts/currentAppId_${APP_NAME}_${platform}_uat
  appId=`curl -s -X POST "${serverUrl}/api/apps/${teamId}/upload" \
        -H "accept: application/json" \
        -H "Authorization: Bearer ${token}" \
        -H "content-type: multipart/form-data" \
        -F "file=@$filePath;type=application/vnd.${platform}.package-archive" | python -mjson.tool | grep appId | awk -F'[:"]' '{print $5}' | head -1`

  if [[ "$appId" == "" ]]; then
    return -1
  else
    echo "$appId" > ${currentAppIdFile}
    return 0
  fi
}

function buildAndroid() {
  #for android
  PLATFORM="android"
  cd ${WORKSPACE}
  sed -i "" "s;^ *export const ENV *= *'.*';export const ENV = '${ENV}';g" ${WORKSPACE}/component/Common/Environment.js
  rm -fr ${WORKSPACE}/android/app/src/main/Android.bundle.zip
  echo "Starting android: npm install"
  npm install > /dev/null
  echo "Starting android: npm run build-android"
  npm run build-android > /dev/null
  cd android
  # currentAppVersionName=`cat gradle.properties |grep appVersionCode|awk -F '=' '{print $2}'`
  # currentAppVersionName=$(( $currentAppVersionName + 1 ))
  # sed -i "" "s;appVersionCode=.*;appVersionCode=${currentAppVersionName};" gradle.properties
  rm -fr $output/*.apk
  echo "Starting android: ./gradlew clean assemble$BUILD_TYPE"
  if [[ "$BUILD_TYPE" == "Release" ]]; then
    output=app/build/outputs/apk/release/
    ./gradlew clean assembleRelease --stacktrace -PIS_JENKINS=true -PBUILD_TYPE=${BUILD_TYPE} > /dev/null
  else
    output=app/build/outputs/apk/debug/
    ./gradlew clean assembleDebug --stacktrace -PIS_JENKINS=true -PBUILD_TYPE=${BUILD_TYPE} > /dev/null
  fi
  
  if [[ $? == 0 ]]; then
    # hot update package
    currPwd=`pwd`
    cd ${WORKSPACE}/android/app/src/main/assets
    zip -rq ../Android.bundle.zip *
    cd $currPwd
    apkFile=`ls $output|grep apk`
    if [[ -f $output/$apkFile ]]; then
      filePath=$output/$apkFile
      uploadApp $PLATFORM $filePath
      if [[ $? != 0 ]]; then
        # exception
        echo "Deleting the maximum version..."
        deleteMaxApp $PLATFORM
        uploadApp $PLATFORM $filePath
      fi
    fi
  else
    echo "Android build failure. exit."
    exit -1
  fi
}

function buildIos() {
  # for ios
  PLATFORM="ios"
  cd ${WORKSPACE}
  sed -i "" "s;^ *export const ENV *= *'.*';export const ENV = '${ENV}';g" ${WORKSPACE}/component/Common/Environment.js
  rm -fr ${WORKSPACE}/ios/IOS.bundle.zip
  echo "Starting ios: npm install"
  npm install > /dev/null
  echo "Starting ios: npm run build-ios"
  npm run build-ios > /dev/null
  cd ios

  echo "Starting ios: pod install"
  /usr/local/bin/pod install

  output=build/outputs/
  rm -fr $output/*.ipa $output/*.xcarchive

  echo "Starting ios: xcodebuild clean"
  xcodebuild \
      -workspace "${APP_NAME}.xcworkspace" \
      -scheme "${APP_NAME}"  \
      -configuration "${BUILD_TYPE}" \
      clean > /dev/null

  echo "Starting ios: xcodebuild archive"
  xcodebuild archive -workspace "${APP_NAME}.xcworkspace" \
      -scheme ${APP_NAME} \
      -configuration "${BUILD_TYPE}" \
      -archivePath "${output}/${APP_NAME}-${BUILD_TYPE}.xcarchive" > /dev/null

  cat << EOF > ./build.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>method</key>
  <string>development</string>
  <key>compileBitcode</key>
  <false/>
</dict>
</plist>
EOF

  echo "Starting ios: xcodebuild export exportArchive to ipa"
  xcodebuild -exportArchive -archivePath "${output}/${APP_NAME}-${BUILD_TYPE}.xcarchive" \
    -exportPath "${output}/${APP_NAME}-${BUILD_TYPE}.ipa" \
    -exportOptionsPlist build.plist  > /dev/null

  if [[ $? == 0 ]]; then
    currPwd=`pwd`
    cd ${WORKSPACE}/ios/bundle
    zip -rq ../IOS.bundle.zip *
    cd $currPwd
    ipaFile=`ls $output|grep ipa`
    if [[ -d $output/$ipaFile ]]; then
      filePath=$output/$ipaFile/${APP_NAME}.ipa
      uploadApp $PLATFORM $filePath
      if [[ $? != 0 ]]; then
        # exception
        echo "Deleting the maximum version..."
        deleteMaxApp $PLATFORM
        uploadApp $PLATFORM $filePath
      fi
    fi
  else
    echo "IOS build failure. exit."
    exit -1
  fi
}

if [[ "$BUILD_PLATFORM" == "android" ]]; then
  buildAndroid
elif [[ "$BUILD_PLATFORM" == "ios" ]]; then
  buildIos
elif [[ "$BUILD_PLATFORM" == "both" ]]; then
  buildAndroid
  buildIos
fi

if [[ "$ENV" == "prod" ]]; then
  echo "Tagging the release version for prod..."
  releaseBranch=${GIT_BRANCH//origin\//}
  newTag=${releaseBranch}-`date +%Y%m%d%H%M`
  git tag -a $newTag -m "For prod version ${newTag} based on $releaseBranch"
  git push origin ${newTag}
fi
```

## 参考

- http://zhangzr.cn/2018/07/27/iOS%E5%BC%80%E5%8F%91-%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6/
- https://www.jianshu.com/p/38b2e17ced73
- https://juejin.im/post/5b6a542b5188251a9e171bf2
- https://blog.csdn.net/li530893850/article/details/70889763
- https://blog.csdn.net/zrina1314/article/details/80102199

