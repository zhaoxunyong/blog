---
title: Docker学习总结
date: 2017-01-03 11:28:07
categories: ["docker"]
tags: ["docker"]
---
docker是个好东西，虽然年轻，但很有前途。一些大的公司(包括谷歌、IBM、惠普、微软等)都有在使用。有些人不太愿意使用新的技术，怕不稳定，但我个人认为好的东西主要勇于使用，大公司都在使用，怕什么呢，新技术不敢于使用，怎么能进步呢^_^
docker相关的概念请大家自行谷歌。新的技术用百度是搜索不到的，还是谷歌好...
如果是没有docker基础的话，建议买一本<<第一本docker书 修订版>>，入门不错。
docker正式环境只能在linux中使用，所以本文以vagrant+centos7为例介绍。具体环境请参考[Vagrant环境搭建](Vagrant环境搭建.html)

## 操作系统要求
Docker只能运行在64位Linux中，并且内核需要3.8以上，建议使用centos 7版本。以下是我本机的环境，请参考：
```bash
[root@www ~] cat /etc/redhat-release 
CentOS Linux release 7.2.1511 (Core) 
[root@www ~] uname -a
Linux www.mymydocker.com 3.10.0-327.4.5.el7.x86_64 #1 SMP Mon Jan 25 22:07:14 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
[root@www ~] ll /sys/class/misc/device-mapper
lrwxrwxrwx 1 root root 0 Dec 13 08:19 /sys/class/misc/device-mapper -> ../../devices/virtual/misc/device-mapper
[root@www ~] grep device-mapper /proc/devices 
253 device-mapper
```

## 安装docker

### 卸载旧的docker版本
当前docker最新版本为1.12，请先卸载旧的docker版本：
```bash
rpm -e docker-1.10.3-59.el7.centos.x86_64 \
 docker-common-1.10.3-59.el7.centos.x86_64 \
 container-selinux-1.10.3-59.el7.centos.x86_64
```

修改配置：
```bash
#修改时区
ln -sf /usr/share/zoneinfo/Asia/Chongqing /etc/localtime

#关闭内核安全
sed -i 's;SELINUX=.*;SELINUX=disabled;' /etc/selinux/config
setenforce 0
getenforce

#关闭防火墙
systemctl disable iptables firewalld
systemctl stop iptables firewalld

#优化内核
cat /etc/security/limits.conf|grep 65535 > /dev/null
if [[ $? != 0 ]]; then
cat >> /etc/security/limits.conf  << EOF
*               soft    nofile             65535
*               hard    nofile             65535
*               soft    nproc              65535
*               hard    nproc              65535
EOF
fi

#打开端口转发
#永久修改：/etc/sysctl.conf中的net.ipv4.ip_forward=1，生效：sysctl -p
#临时修改：echo 1 > /proc/sys/net/ipv4/ip_forward，重启后失效

cat /etc/sysctl.conf|grep "net.ipv4.ip_forward" > /dev/null
if [[ $? != 0 ]]; then
cat >> /etc/sysctl.conf  << EOF
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_keepalive_time = 300
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.ip_forward = 1
EOF
sysctl -p
fi


su -

### 添加docker用户组
注意：rpm安装已经自动创建了该组，无需再创建。
```bash
groupadd -g 2016 docker
#useradd docker -u 2016 -g 2016
```
当发现有docker组时，会自动以docker组启动。

### 添加yum源：
```bash
tee /etc/yum.repos.d/docker.repo <<-'EOF'
[docker]
name=Docker Repository
baseurl=http://mirrors.aliyun.com/docker-engine/yum/repo/main/centos/7/
enabled=1
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/docker-engine/yum/gpg
EOF
```

### 安装
```bash
yum install docker-engine
```

### 手动启动
rpm安装的通过systemctl start docker启动。如果是二进制文件的话，通过以下方式启动：
```bash
#默认以/var/run/docker.sock文件监听
#手动启动：
#-D为debug
docker daemon -D -H tcp://0.0.0.0:2375 \
 -H unix://var/run/docker.sock
```

### docker加速
官网的速度太慢了，可以使用daocloud加速。请参考[what-is-daocloud-accelerator](http://docs.daocloud.io/faq/what-is-daocloud-accelerator)
具体操作如下：
> 注册https://www.daocloud.io/账户
> 点击加速器，获取地址
> 修改/usr/lib/systemd/system/docker.service文件：
```bash
#ExecStart=/usr/bin/dockerd --bip=10.1.10.1/24 --insecure-registry=172.28.3.96:5000 --registry-mirror=http://3fecfd09.m.daocloud.io
sed -i "s;^ExecStart=/usr/bin/dockerd$;ExecStart=/usr/bin/dockerd \
--registry-mirror=http://3fecfd09.m.daocloud.io;" \
 /usr/lib/systemd/system/docker.service
```

### 添加代理
国内网站无法访问google的一些资源，可以通过docker代理方式访问：
```bash
mkdir -p /etc/systemd/system/docker.service.d
cat >> /etc/systemd/system/docker.service.d/http-proxy.conf  << EOF
[Service]
Environment="HTTP_PROXY=http://xxxx:xxxx"
Environment="HTTPS_PROXY=http://xxxx:xxxx"
Environment="NO_PROXY=localhost,127.0.0.1,docker.io"
EOF

systemctl daemon-reload
systemctl show --property=Environment docker

systemctl restart docker
systemctl enable docker
```
然后 ps aux | grep docker 然后你就会发现带有镜像的启动参数了。

由于我这边的HTTP_PROXY与HTTPS_PROXY是付费购买的，同时只能几个client访问，需要的话请自行搜索或者购买。

## docker私服搭建
参考
> http://www.cnblogs.com/lienhua34/p/4922130.html
> https://docs.docker.com/registry/deploying/

### 安装registry:2

#### 普通安装方式
安装：
```bash
docker create -p 5000:5000 --restart=always --name private_registry \
 -v /docker/registry:/var/lib/registry registry:2
```
映射主机的/docker/registry目录到容器的/var/lib/registry

异常解决：
当出现Get https://192.168.10.6:5000/v1/_ping: Connection failed错误时，由于改为http方式，需要修改以下配置：
```bash
vim /usr/lib/systemd/system/docker.service
#添加--insecure-registry参数
ExecStart=/usr/bin/dockerd --insecure-registry=192.168.10.6:5000
#重启
systemctl daemon-reload
systemctl restart docker
```

#### 证书安装方式
> 参考: https://www.tianmaying.com/tutorial/docker-registry
先/etc/pki/tls/openssl.cnf配置，在该文件中找到[ v3_ca ]，在它下面添加如下内容：
```bash
[ v3_ca ]
# Extensions for a typical CA
subjectAltName = IP:172.28.3.96
```

安装：
```bash
openssl req \
  -subj "/C=CN/ST=GuangDong/L=GuangZhou/CN=172.28.3.96:5000" \
  -newkey rsa:4096 -nodes -sha256 -keyout domain.key \
  -x509 -days 365 -out domain.crt 

mkdir -p /etc/docker/certs.d/172.28.3.96:5000
cp domain.crt /etc/docker/certs.d/172.28.3.96:5000/ca.crt
mkdir -p /root/certs/
cp domain.crt domain.key /root/certs/

docker run \
    -d \
    --name private_registry  --restart=always \
    -e SETTINGS_FLAVOUR=dev \
    -e STORAGE_PATH=/registry-storage \
    -v /docker/registry:/var/lib/registry \
    -u root \
    -p 5000:5000 \
    -v /root/certs:/certs \
    -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
    -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \
    registry:2
```
注意：如果采用证书方式，需要去掉/usr/lib/systemd/system/docker.service中的--insecure-registry参数，然后再重启：
```bash
systemctl daemon-reload
systemctl restart docker
```

如果要用docker pull或者docker push的客户端，都需要执行以下命令：
```bash
mkdir -p /etc/docker/certs.d/172.28.3.96:5000
cp domain.crt /etc/docker/certs.d/172.28.3.96:5000/ca.crt
```
否则，会报以下错误：
```bash
Error response from daemon: Get https://172.28.3.96:5000/v1/_ping: x509: certificate signed by unknown authority
```

#### 测试
```bash
docker pull elasticsearch
docker tag elasticsearch 172.28.3.96:5000/elasticsearch
docker push 172.28.3.96:5000/elasticsearch
```

#### 删除镜像文件
删除private registry中的镜像：
docker exec -it private_registry /bin/sh
删除/var/lib/registry/docker/registry/v2/repositories目录下对应的目录

### 启动
```bash
docker start registry
```

### 查看ip
```bash
docker exec registry ip addr
```

## 导入本地的images到私服中
push.sh:
```bash
#!/bin/sh
imgs=$(docker images|awk '{print $1":"$2}')
for img in $imgs
do
  docker tag $img 172.28.3.96:5000/$img
  docker push 172.28.3.96:5000/$img
  docker rmi 172.28.3.96:5000/$img
done
```

pull.sh:
```bash
#!/bin/sh
imgs=$(docker images|awk '{print $1":"$2}')
for img in $imgs
do
  docker pull 172.28.3.96:5000/$img
  docker tag 172.28.3.96:5000/$img $img
  docker rmi 172.28.3.96:5000/$img
done
```

## 安装shipyard
shipyard可以通过web的方式操作本地的镜像，还可以浏览指定的private registry，具体安装方式如下：
```bash
#dockerui:
#docker run -d -p 9000:9000 --name dockerui -v /var/run/docker.sock:/var/run/docker.sock uifd/ui-for-docker
#docker start dockerui
#curl -s https://shipyard-project.com/deploy | bash -s
wget -O shipyard.sh https://shipyard-project.com/deploy
```

安装：
```bash
export ACTION=deploy;export PORT=9001;sh shipyard.sh
```

更新：
```bash
export ACTION=upgrade;export PORT=9001;sh shipyard.sh
```

移除：
```bash
export ACTION=remove;sh shipyard.sh
```

更多查看：
```bash
sh shipyard.sh -h
```

访问地址：
```bash
http://172.28.3.96:9001/
```

注意：
> 防火墙要放行2375端口，否则看不到container
> 添加registry时，需要指定https的地址，如：https://172.28.3.96:5000
login: admin/shipyard


## 安装registry ui
可以使用docker-registry-frontend，具体安装方式如下：

### 普通安装方式
```bash
#docker run -d -p 8080:8080 atcol/docker-registry-ui(不支持V2，不能使用)
sudo docker run \
  -d \
  -e ENV_DOCKER_REGISTRY_HOST=172.28.3.96 \
  -e ENV_DOCKER_REGISTRY_PORT=5000 \
  -p 9002:80 \
  konradkleine/docker-registry-frontend:v2
#重启：
docker stop $(docker ps -a |grep docker-registry-frontend|awk '{print $1}')
docker start $(docker ps -a |grep docker-registry-frontend|awk '{print $1}')
```
访问：
```bash
http://172.28.3.96:9002
```

### 证书安装方式
```bash
sudo docker run \
  -d \
  -e ENV_DOCKER_REGISTRY_HOST=172.28.3.96 \
  -e ENV_DOCKER_REGISTRY_PORT=5000 \
  -e ENV_DOCKER_REGISTRY_USE_SSL=1 \
  -e ENV_USE_SSL=yes \
  -v /root/certs/domain.crt:/etc/apache2/server.crt:ro \
  -v /root/certs/domain.key:/etc/apache2/server.key:ro \
  -p 9002:443 \
  konradkleine/docker-registry-frontend:v2
```

异常解决：
如果出现The proxy server could not handle the request GET /v2/_catalog的错误，需要添加：
```bash
-e ENV_DOCKER_REGISTRY_USE_SSL=1
```

访问：
https://172.28.3.96:9002

## 基本命令
创建容器交互式容器：
docker run --name web -i -t docker.io/centos /bin/bash
--name：容器命名
--rm: 创建并运行一次后自动删除
-d: 守护式容器，不加-d的话，会直接进入docker命令行，exit后容器也退出了。
--restart=on-failure:5 当容器退出代码为非0时，自动尝试重启5次
--restart=always 容器退出时，总会自动启动

显示正在运行的容器：
docker ps

显示所有的容器：
docker ps -a

显示最后一个运行的容器：
docker ps -l

删除：
docker rm <CONTAINER ID>

停止所有的docker容器：

docker stop $(docker ps -q -a)

启动与停止：
docker start <NAME>
docker stop <NAME>

进入已启动的容器:
docker attach <NAME>
注意：进入容器后，执行exit后，容器会关掉。要：CTRL+P+Q才不会退出容器
docker rm后，再创建容器会恢复到原始内容。

查看已运行的容器日志：
docker run --name daemon_dave -d docker.io/centos /bin/sh -c "while true;do echo hello world;sleep 1;done"
docker run --log-driver="syslog" --name dave -d docker.io/centos /bin/sh -c "while true;do echo hello world;sleep 1;done"
docker logs --tail -n100 -f web或docker logs -f web
--log-driver="syslog": 将日志输出到/var/log/message中，通过docker logs会禁用

容器内进程：
docker top|stats <NAME1> <NAME2>

在容器外部执行容器内的命令：
docker exec -d web touch /etc/new_config_file
docker exec -t -i web /bin/bash类似于docker attach web，但容器不会自动退出

docker的目录：
/var/lib/docker，包括了镜像、配置。

显示本机中的docker镜像：
docker images

搜索：
docker search redis

checkout：
docker login
docker pull docker.io/redis

commit到hub.docker.com：
commit本机：
docker commit -m "A newcustom image" -a "zhaoxunyong" redis zhaoxunyong/redis:1.0.0-SNAPSHOT
commit到hub.docker.com:
docker push zhaoxunyong/redis:1.0.0-SNAPSHOT

指定端口：
docker run -d -p 80 --name nginx zhaoxunyong/mycentos nginx -g "daemon off;"
docker run -d -p 8080:80 --name nginx zhaoxunyong/mycentos nginx -g "daemon off;"
-p 8080:80: 表示把容器中的80端口映射到宿主机的8080端口
run -d -P --name nginx zhaoxunyong/mycentos nginx -g "daemon off;" 
-P：表示将Dockerfile中的EXPOSE端口对外分布

查看映射的端口：
docker port nginx 80

## Dockerfile
CMD ["", ""]
注意：CMD只能指定一条。如果docker run有传cmd的话，Dockerfile中的CMD无效

ENTRYPOINT ["", ""]
不会被外面的参数覆盖，同时CMD或者外面传的参数会作为ENTRYPOINT的参数
也可以在外面：docker run --entrypoint覆盖ENTRYPOINT指令

WORKDIR:
脚本运行的工作目录,目录会自动创建。
也可以在外面： -w覆盖WORKDIR指令

设置环境变更：
ENV WORK_HOME /zxy
WORKDIR $WORK_HOME
进入容器可以通过env查看
也可以通过外面：-e "WORK_HOME=/zxy"指定

USER nginx
指定运行的用户，不指定默认root

VOLUME:
VOLUME ["/data"]
创建一个可以从本地主机或其他容器挂载的挂载点

LABEL:
LABEL location="New York" type="Data Center" role="Web Server"

COPY/ADD:
添加文件，ADD与COPY不同之处在于如果文件是压缩文件，ADD到容器中会自动解压。
支持http方式。

ARG:
构建时，传递参数给构建：
ARG build
ARG webapp_user=user(user为默认值)
传递参数：--build-arg build=1234
如：docker build --build-arg build=1234 -t zhaoxunyong/mycentos ./

ONBUILD:
触发器：在另外有构建基于这个构建时触发，只能继承一次
如：ONBUILD ADD test.sh /software/

挂载目录到容器
-v $PWD/website:/var/www/html/website:ro
挂载website目录到容器的var/www/htmlwebsite，权限为ro, rw为可读写(默认) ro为只读

--volumes-from containername
把containername所有的VOLUME挂载到新容器中。

构建：docker build --no-cache -t="zhaoxunyong/mycentos:latest" ./
--no-ache表示每次都会从头到尾构建
docker images
查看历史记录：
docker history <IMAGE.NAME>

## 网络连接
### Networking
版本>=1.9推荐使用。
docker network create app
docker network inspect app
docker network ls

创建：
docker run -d --net=app --name db docker.io/redis
docker run -it --net=app --name centos docker.io/centos /bin/bash

测试：
进入docker exec -it centos /bin/bash，ping db就可以ping通
进入docker exec -it db /bin/bash，ping centos也可以ping通

加入到app网络：
docker run -d -p 8088:80 --name nginx docker.io/nginx
docker network connect app nginx
进入docker exec -it nginx /bin/bash，ping db或centos就能ping通
/etc/hosts中没有对应的记录。还不清楚在哪设置的,好像 the embedded DNS server reachable at 127.0.0.11，https://docs.docker.com/engine/userguide/networking/#/docker-embedded-dns-server

断开：
docker network disconnect app nginx

### Link
link:1.9之前版本使用：
--link 原containername:别名
只支持在相同的宿主机中。
可以多次使用--link
docker run -d --name db docker.io/redis 
docker run -d -p 8088:80 --name nginx --link db:redis_db docker.io/nginx
进入docker exec -it nginx /bin/bash，ping redis_db就能ping通, /etc/hosts可以看到对应的记录。
可以在容器中通过env查看环境变量
--icc=false:关闭所有没有链接的容器间的通信

## Docker compose
### 安装pip
yum install python2-pip

### 安装compose
pip install -U docker-compose
docker-compose --version

### Demo

编写Dockerfile:
vim redis/Dockerfile
```bash
# Version: 1.0.0
FROM docker.io/centos
MAINTAINER zhaoxunyong@qq.com

RUN yum -y install epel-release
RUN yum -y install redis

VOLUME [ "/var/lib/redis", "/var/log/redis" ]

#ENTRYPOINT [ "redis-server", "--logfile", "/var/log/redis/redis-server.log" ]
ENTRYPOINT [ "redis-server" ]

EXPOSE 6379
```
编译：
```bash
docker build -t zhaoxunyong/redis ./
```

vim nginx/Dockerfile
```bash
# Version: 1.0.0
FROM docker.io/centos

RUN yum -y install epel-release
RUN yum -y install nginx

EXPOSE 80

#CMD [ "nginx", "-g", "daemon off;"]

docker build -t zhaoxunyong/ngnix ./
```

编译：
```bash
docker build -t zhaoxunyong/ngnix ./
```

compose:
vim docker-compose.yml
```bash
web:
  image: zhaoxunyong/nginx
  command: nginx -g 'daemon off;'
  ports:
    - "8081:80"
  links:
    - redis

redis:
  image: zhaoxunyong/redis
  ports:
    - "6379:6379"
```

启动：
```bash
docker-compose up
docker-compose up -d
docker-compose ps
docker-compose logs
docker-compose logs -f
docker-compose stop
```

## consul
> 参考：http://blog.csdn.net/mn960mn/article/details/51753893
```bash
docker rm -v $(docker ps -a|grep consul |awk '{print $1}')

docker network create app

consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n1 -bind=你的ip -dc=dc1

docker run -d --name consul1 --net=app -p 8400:8400 -p 8500:8500 -p 8600:8600 -h consul1 zhaoxunyong/consul \
 -server -bootstrap -bind=0.0.0.0 -client=172.18.0.2 -data-dir=data -ui -node=node1

docker run -d --name consul2 --net=app -p 8401:8400 -p 8501:8500 -h consul2 zhaoxunyong/consul \
 -bind=0.0.0.0 -client=172.18.0.3 -data-dir=data -node=node2 -join=172.18.0.2

docker run -d --name consul3 --net=app -p 8402:8400 -p 8502:8500 -h consul3 zhaoxunyong/consul \
 -bind=0.0.0.0 -client=172.18.0.4 -data-dir=data -node=node3 -join=172.18.0.2

docker exec consul1 bin/consul members -rpc-addr=172.18.0.2:8400

docker start consul1 consul2 consul3
```

http://192.168.10.9:8500/


